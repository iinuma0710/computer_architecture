# 命令の実行

今回は、コンピュータ上でどのように命令が実行されるのかについてみていきます。

## 命令実行のステージ
コンピュータ上で1つの命令を実行するにしても、命令やデータをメモリから読み込んだり、演算を実行した結果をメモリに書き込んだり、さまざまな処理が必要となります。
一般的に、命令の処理はいくつかのステージに分けられます。
最近のプロセッサでは十数段階に分割している場合もありますが、RISC-V では5段階に分けられます。

### 命令フェッチ (Instruction Fetch: IF)
IF ステージでは、メモリに格納されている命令を読み出してきます。
命令を読み出してくるアドレスは、プログラムカウンタ (Program Counter: PC) と呼ばれるレジスタに格納されています。
RISC-V では、32本のレジスタとは別に PC 専用のレジスタが用意されており、実装を分けることでハードウェアを簡素化しています。

### 命令デコード (Instruction Decode: ID)
ID　ステージでは、0/1 のビット列である機械語から、命令の意味を解読 (デコード) します。
この解読方法を定義したのが命令セットアーキテクチャ (ISA) です。
RISC-V では、32ビットの命令のうち、0〜6ビット目は ```opcode``` と定められていますが、それ以外は命令の種類によって、レジスタのアドレスを指定したり即値を設定したリト、いくつかのパターンに分かれます。

### 演算 (EXecution: EX)
EX ステージでは、ID ステージのデコード結果を受けて、命令で指定された、四則演算やシフト演算などの処理を実行します。

### メモリアクセス (MEMory access: MEM)
MEM ステージでは、メモリへの書き出しや読み出しを行います。
RISC-V でメモリへのアクセスはロード命令とストア命令に限定され、算術演算やシフト演算を行う命令ではメモリにアクセスできません。
ロード・ストア命令では、直前の EX ステージで読み書きするメモリのアドレスを計算し、MEM ステージでメモリにアクセスします。
それ以外の命令では MEM ステージは稼働しません。

### ライトバック (Write Back: WB)
最後に、WB ステージで演算結果やメモリからのロード結果をレジスタに書き込みます。

## 命令のパイプライン化
通常、複数の命令を組み合わせることでプログラムが出来上がります。
命令を実行するときに、1個1個の命令を順番に実行すると、下の表のようなサイクルで実行することになります。

| サイクル | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 命令1 | IF | ID | EX | MEM | WB |  |  |  |  |  |  |  |  |  |  |
| 命令2 |  |  |  |  |  | IF | ID | EX | MEM | WB |  |  |  |  |  |
| 命令3 |  |  |  |  |  |  |  |  |  |  | IF | ID | EX | MEM | WB |

プログラムの実行上は、これでも特に問題はありませんが、ハードウェアの利用効率が非常に悪くなります。
たとえば、命令2の IF ステージ実行中、他のステージを実行するハードウェアは全く利用されません。
そのため、3つの命令を処理するのに15サイクルもかかってしまいます。  
そこで、「命令1の ID ステージ処理中に、命令2の IF ステージの処理を実行する」、といったように利用されていないハードウェアを並列的に動かすことで利用効率を上げることができます。
これをパイプライン処理と呼び、上記のプログラムをパイプライン処理すると下の表のようになります。

| サイクル | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 命令1 | IF | ID | EX | MEM | WB |  |  |
| 命令2 |  | IF | ID | EX | MEM | WB |  |
| 命令3 |  |  | IF | ID | EX | MEM | WB |

こうすることで、元の半分以下の7サイクルでプログラムが完了します。
実際のプログラムでは、条件分岐やデータハザードなどの阻害要因があるため、より複雑な制御が必要となりますが、それも含めて今後実装していく予定です。