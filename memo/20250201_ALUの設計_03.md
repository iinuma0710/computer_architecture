# ALU の設計 その3：全加算器や加算器の実装
前回は、半加算器を SystemVerilog で実装して、テストベンチで動作確認を行いました。
今回は、これをベースに全加算器や多ビットの加算器を実装していきます。

## 全加算器の実装
全加算器は半加算器2つと OR ゲートを利用して実装できます。
ただ、半加算器が2つあると信号線の名前がかぶってしまうので、図1のように信号線の名前を付けなおします。

<div align="center">
    <img src="../images/full_adder_implementation.drawio.png" width=600>
    <figcaption>図 1. 全加算器の信号名</figcaption>
</div>

これを SystemVerilog に起こすと以下のような記述になります。

```fulladder.sv```
```systemverilog
`include "halfadder.sv"

module fulladder(
    input  logic a, b, cin,
    output logic s, cout
);
    // 内部信号の宣言
    logic s0, c0, c1;
    // 1段目の半加算器のインスタンスを生成
    halfadder ha0(.a(a), .b(b), .s(s0), .c(c0));
    // 2段目の半加算器のインスタンスを生成
    halfadder ha1(.a(s0), .b(cin), .s(s), .c(c1));

    always_comb begin
        cout = c0 | c1;
    end
endmodule
```

まず、半加算器の実装がもとになるので ```halfadder.sv``` を読み込んでおきます。
モジュールの入出力信号の宣言は半加算器の場合と同様です。
全加算器ではモジュールの入出力以外に、2つの半加算器や OR ゲートの間をつなぐために内部信号が必要となるので、```s0```、```c0```、```c1``` の3本の内部信号を宣言しておきます。
全加算器の1段目の半加算器を ```ha0```、2段目の半加算器を ```ha1``` としてインスタンス化します。
それぞれ、入出力信号を接続してあるので、全加算器の入力を変化させれば出力 ```s``` は定まります。
ただ、```cout``` は内部信号 ```c0``` と ```c1``` の OR を取らなければならないので、```always_comb``` ブロックの中で ```cout``` を計算します。  
全加算器が実装できたので、全加算器のテストベンチを書きます。
基本的には半加算器の場合と同様で、入力のパターンを列記して出力状態を目視で確認します。

```test_fulladder.sv```
```systemverilog
`include "fulladder.sv"

module test_halfadder();
    logic a, b, cin; // 入力信号
    logic s, cout;   // 出力信号

    // 半加算器のインスタンスを作成
    fulladder _fulladder (.a(a), .b(b), .cin(cin), .s(s), .cout(cout));

    initial begin
        $display("a b cin || s cout");
        $display("--------++-------");

        // テストパターンを試す
        a = 0; b = 0; cin = 0; #10; $display("%d %d  %d  || %d  %d", a, b, cin, s, cout);
        a = 0; b = 0; cin = 1; #10; $display("%d %d  %d  || %d  %d", a, b, cin, s, cout);
        a = 0; b = 1; cin = 0; #10; $display("%d %d  %d  || %d  %d", a, b, cin, s, cout);
        a = 0; b = 1; cin = 1; #10; $display("%d %d  %d  || %d  %d", a, b, cin, s, cout);
        a = 1; b = 0; cin = 0; #10; $display("%d %d  %d  || %d  %d", a, b, cin, s, cout);
        a = 1; b = 0; cin = 1; #10; $display("%d %d  %d  || %d  %d", a, b, cin, s, cout);
        a = 1; b = 1; cin = 0; #10; $display("%d %d  %d  || %d  %d", a, b, cin, s, cout);
        a = 1; b = 1; cin = 1; #10; $display("%d %d  %d  || %d  %d", a, b, cin, s, cout);
    end
endmodule
```

コマンドを実行して動作を確認しましょう。
うまく動いていそうです。

```bash
$ iverilog -g 2012 -o test_fulladder test_fulladder.sv
$ vvp test_fulladder
a b cin || s cout
--------++-------
0 0  0  || 0  0
0 0  1  || 1  0
0 1  0  || 1  0
0 1  1  || 0  1
1 0  0  || 1  0
1 0  1  || 0  1
1 1  0  || 0  1
1 1  1  || 1  1
```